name: Deploy Cluster Infrastructure

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'infra/addons/**'
      - '.github/workflows/deploy-addons.yml'

jobs:
  # mirror-images:
  #   name: Mirror Images to ACR
  #   runs-on: ubuntu-latest
  #   env:
  #     ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
  #     ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
  #     ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
  #   steps:
  #     - name: Login to ACR
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ${{ secrets.ACR_REGISTRY }}
  #         username: ${{ secrets.ACR_USERNAME }}
  #         password: ${{ secrets.ACR_PASSWORD }}
  #
  #     - name: Mirror NGINX Ingress Controller image
  #       shell: bash
  #       run: |
  #         SOURCE_IMAGE="registry.k8s.io/ingress-nginx/controller:v1.9.4"
  #         TARGET_IMAGE="${{ secrets.ACR_REGISTRY }}/ingress-nginx/controller:v1.9.4"
  #         docker pull "$SOURCE_IMAGE"
  #         docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE"
  #         docker push "$TARGET_IMAGE"
  #         echo "✅ Mirrored: $SOURCE_IMAGE → $TARGET_IMAGE"
  #
  #     - name: Mirror Prometheus image
  #       shell: bash
  #       run: |
  #         SOURCE_IMAGE="quay.io/prometheus/prometheus:v2.48.0"
  #         TARGET_IMAGE="${{ secrets.ACR_REGISTRY }}/prometheus/prometheus:v2.48.0"
  #         docker pull "$SOURCE_IMAGE"
  #         docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE"
  #         docker push "$TARGET_IMAGE"
  #         echo "✅ Mirrored: $SOURCE_IMAGE → $TARGET_IMAGE"
  #
  #     - name: Mirror Grafana image
  #       shell: bash
  #       run: |
  #         SOURCE_IMAGE="docker.io/grafana/grafana:10.2.0"
  #         TARGET_IMAGE="${{ secrets.ACR_REGISTRY }}/grafana/grafana:10.2.0"
  #         docker pull "$SOURCE_IMAGE"
  #         docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE"
  #         docker push "$TARGET_IMAGE"
  #         echo "✅ Mirrored: $SOURCE_IMAGE → $TARGET_IMAGE"
  #
  #     - name: Mirror Alertmanager image
  #       shell: bash
  #       run: |
  #         SOURCE_IMAGE="quay.io/prometheus/alertmanager:v0.26.0"
  #         TARGET_IMAGE="${{ secrets.ACR_REGISTRY }}/prometheus/alertmanager:v0.26.0"
  #         docker pull "$SOURCE_IMAGE"
  #         docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE"
  #         docker push "$TARGET_IMAGE"
  #         echo "✅ Mirrored: $SOURCE_IMAGE → $TARGET_IMAGE"
  #
  #     - name: Mirror Metrics Server image
  #       shell: bash
  #       run: |
  #         SOURCE_IMAGE="registry.k8s.io/metrics-server/metrics-server:v0.6.4"
  #         TARGET_IMAGE="${{ secrets.ACR_REGISTRY }}/metrics-server/metrics-server:v0.6.4"
  #         docker pull "$SOURCE_IMAGE"
  #         docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE"
  #         docker push "$TARGET_IMAGE"
  #         echo "✅ Mirrored: $SOURCE_IMAGE → $TARGET_IMAGE"
  #
  #     - name: Mirror Local Path Provisioner image
  #       shell: bash
  #       run: |
  #         SOURCE_IMAGE="rancher/local-path-provisioner:v0.0.26"
  #         TARGET_IMAGE="${{ secrets.ACR_REGISTRY }}/rancher/local-path-provisioner:v0.0.26"
  #         docker pull "$SOURCE_IMAGE"
  #         docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE"
  #         docker push "$TARGET_IMAGE"
  #         echo "✅ Mirrored: $SOURCE_IMAGE → $TARGET_IMAGE"

  deploy-infrastructure:
    name: Deploy Base Infrastructure
    runs-on: self-hosted
    env:
      KUBECONFIG_INLINE: ${{ secrets.KUBECONFIG }}
      ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
      ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
      ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare kubeconfig
        shell: bash
        run: |
          mkdir -p "$HOME/.kube"
          KUBECONFIG_PATH="$HOME/.kube/config"
          
          # Check if secret is set
          if [ -z "$KUBECONFIG_INLINE" ]; then
            echo "❌ KUBECONFIG_INLINE is empty!"
            exit 1
          fi
          
          # Write kubeconfig from GitHub Secret (handles both plain text and base64)
          # Try base64 decode first
          DECODED=$(echo -n "$KUBECONFIG_INLINE" | base64 -d 2>/dev/null)
          if [ $? -eq 0 ] && [ -n "$DECODED" ] && echo "$DECODED" | head -n 1 | grep -q "apiVersion:" 2>/dev/null; then
            echo "✅ Detected and decoded base64 kubeconfig"
            cat > "$KUBECONFIG_PATH" <<EOF
          $DECODED
          EOF
          else
            echo "✅ Using plain text kubeconfig"
            # Use heredoc without quotes to allow variable expansion
            cat > "$KUBECONFIG_PATH" <<EOF
          $KUBECONFIG_INLINE
          EOF
          fi
          
          chmod 600 "$KUBECONFIG_PATH"
          
          # Debug: Check what was written
          echo "Kubeconfig file created, size: $(wc -c < "$KUBECONFIG_PATH") bytes"
          echo "First 3 lines (checking format):"
          head -n 3 "$KUBECONFIG_PATH" | sed 's/./?/g' || head -n 3 "$KUBECONFIG_PATH"
          
          # Set KUBECONFIG environment variable for all subsequent steps
          echo "KUBECONFIG=$KUBECONFIG_PATH" >> $GITHUB_ENV
          
          # Verify kubeconfig is valid
          export KUBECONFIG="$KUBECONFIG_PATH"
          if ! kubectl config view --raw > /dev/null 2>&1; then
            echo "❌ Invalid kubeconfig format"
            echo "File size: $(wc -c < "$KUBECONFIG_PATH") bytes"
            echo "First character (hex): $(head -c 1 "$KUBECONFIG_PATH" | od -An -tx1)"
            echo "Checking if file contains 'apiVersion':"
            grep -c "apiVersion" "$KUBECONFIG_PATH" || echo "No 'apiVersion' found"
            echo "First 15 lines (masked for security):"
            head -n 15 "$KUBECONFIG_PATH" | sed 's/./?/g'
            exit 1
          fi
          echo "✅ Kubeconfig is valid (from GitHub Secret)"

      - name: Verify cluster access
        shell: bash
        run: |
          # KUBECONFIG is set via GITHUB_ENV from previous step
          export KUBECONFIG="${KUBECONFIG:-$HOME/.kube/config}"
          if [ ! -f "$KUBECONFIG" ]; then
            echo "❌ Kubeconfig file not found at $KUBECONFIG!"
            exit 1
          fi
          # Test cluster access
          kubectl cluster-info
          kubectl get nodes
          echo "✅ Cluster access verified"

      - name: Check helm installation
        shell: bash
        run: |
          if ! command -v helm >/dev/null 2>&1; then
            echo "❌ Helm is not installed. Please install it on the runner server:"
            echo "   curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash"
            exit 1
          fi
          helm version

      - name: Create ACR imagePullSecret for ingress-nginx namespace
        shell: bash
        run: |
          kubectl get ns ingress-nginx >/dev/null 2>&1 || kubectl create namespace ingress-nginx
          kubectl create secret docker-registry acr-pull \
            --docker-server="${{ secrets.ACR_REGISTRY }}" \
            --docker-username="${{ secrets.ACR_USERNAME }}" \
            --docker-password="${{ secrets.ACR_PASSWORD }}" \
            -n ingress-nginx \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl patch serviceaccount default -n ingress-nginx \
            -p '{"imagePullSecrets":[{"name":"acr-pull"}]}'

      - name: Create ACR imagePullSecret for monitoring namespace
        shell: bash
        run: |
          kubectl get ns monitoring >/dev/null 2>&1 || kubectl create namespace monitoring
          kubectl create secret docker-registry acr-pull \
            --docker-server="${{ secrets.ACR_REGISTRY }}" \
            --docker-username="${{ secrets.ACR_USERNAME }}" \
            --docker-password="${{ secrets.ACR_PASSWORD }}" \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl patch serviceaccount default -n monitoring \
            -p '{"imagePullSecrets":[{"name":"acr-pull"}]}'

      - name: Create ACR imagePullSecret for kube-system namespace
        shell: bash
        run: |
          kubectl create secret docker-registry acr-pull \
            --docker-server="${{ secrets.ACR_REGISTRY }}" \
            --docker-username="${{ secrets.ACR_USERNAME }}" \
            --docker-password="${{ secrets.ACR_PASSWORD }}" \
            -n kube-system \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl patch serviceaccount default -n kube-system \
            -p '{"imagePullSecrets":[{"name":"acr-pull"}]}'

      - name: Create ACR imagePullSecret for local-path-storage namespace
        shell: bash
        run: |
          kubectl get ns local-path-storage >/dev/null 2>&1 || kubectl create namespace local-path-storage
          kubectl create secret docker-registry acr-pull \
            --docker-server="${{ secrets.ACR_REGISTRY }}" \
            --docker-username="${{ secrets.ACR_USERNAME }}" \
            --docker-password="${{ secrets.ACR_PASSWORD }}" \
            -n local-path-storage \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Add Helm repositories
        shell: bash
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update

      - name: Deploy NGINX Ingress Controller
        shell: bash
        run: |
          # KUBECONFIG is set via GITHUB_ENV from Prepare kubeconfig step
          export KUBECONFIG="${KUBECONFIG:-$HOME/.kube/config}"
          kubectl get ns ingress-nginx >/dev/null 2>&1 || kubectl create namespace ingress-nginx
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            -n ingress-nginx \
            -f infra/addons/values/ingress-nginx.yaml \
            --set controller.image.registry="${{ secrets.ACR_REGISTRY }}" \
            --wait --timeout 5m

      - name: Deploy Monitoring Stack (Prometheus + Grafana)
        shell: bash
        run: |
          kubectl get ns monitoring >/dev/null 2>&1 || kubectl create namespace monitoring
          helm upgrade --install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
            -n monitoring \
            -f infra/addons/values/observability.yaml \
            --set grafana.image.registry="${{ secrets.ACR_REGISTRY }}" \
            --set prometheus.prometheusSpec.image.registry="${{ secrets.ACR_REGISTRY }}" \
            --set alertmanager.image.registry="${{ secrets.ACR_REGISTRY }}" \
            --wait --timeout 10m

      - name: Deploy Metrics Server
        shell: bash
        run: |
          if ! kubectl -n kube-system get deploy metrics-server >/dev/null 2>&1; then
            # Download manifest and replace image URL with ACR
            curl -sL https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml | \
              sed "s|registry.k8s.io/metrics-server/metrics-server|${{ secrets.ACR_REGISTRY }}/metrics-server/metrics-server|g" | \
              kubectl apply -f -
            kubectl wait --for=condition=available --timeout=5m deployment/metrics-server -n kube-system
          else
            echo "Metrics Server already deployed"
          fi

      - name: Deploy Local Path Provisioner
        shell: bash
        run: |
          if ! kubectl -n local-path-storage get deploy local-path-provisioner >/dev/null 2>&1; then
            # Download manifest and replace image URL with ACR
            curl -sL https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml | \
              sed "s|rancher/local-path-provisioner:v0.0.26|${{ secrets.ACR_REGISTRY }}/rancher/local-path-provisioner:v0.0.26|g" | \
              kubectl apply -f -
            # Patch ServiceAccount to use imagePullSecret (after it's created)
            sleep 2
            kubectl patch serviceaccount local-path-provisioner-service-account -n local-path-storage \
              -p '{"imagePullSecrets":[{"name":"acr-pull"}]}' || echo "ServiceAccount patched or not found yet"
            kubectl wait --for=condition=available --timeout=5m deployment/local-path-provisioner -n local-path-storage
            # Set as default storage class if not already set
            kubectl patch storageclass local-path -p '{"metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}' || echo "StorageClass already configured"
          else
            echo "Local Path Provisioner already deployed"
            # Ensure imagePullSecret is set even if already deployed
            kubectl patch serviceaccount local-path-provisioner-service-account -n local-path-storage \
              -p '{"imagePullSecrets":[{"name":"acr-pull"}]}' || echo "ServiceAccount already patched"
          fi

      - name: Verify deployments
        shell: bash
        run: |
          echo "=== Ingress Controller ==="
          kubectl get pods -n ingress-nginx
          echo ""
          echo "=== Monitoring Stack ==="
          kubectl get pods -n monitoring
          echo ""
          echo "=== Metrics Server ==="
          kubectl get pods -n kube-system | grep metrics-server
          echo ""
          echo "=== Local Path Provisioner ==="
          kubectl get pods -n local-path-storage
          echo ""
          echo "=== Storage Classes ==="
          kubectl get storageclass
          echo ""
          echo "=== Cluster Status ==="
          kubectl top nodes || echo "Metrics not yet available (may take a few minutes)"

      - name: Summary
        shell: bash
        run: |
          echo "✅ Cluster Infrastructure deployed successfully!"
          echo "  - NGINX Ingress Controller: ingress-nginx namespace"
          echo "  - Prometheus + Grafana: monitoring namespace"
          echo "  - Metrics Server: kube-system namespace"
          echo "  - Local Path Provisioner: local-path-storage namespace"
          echo "  - All images pulled from ACR: ${{ secrets.ACR_REGISTRY }}"


