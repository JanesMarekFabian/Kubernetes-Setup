RBAC Setup für CI/CD ServiceAccount:
Architektur:
ServiceAccount: cicd-deploy (im Namespace kube-system)
ClusterRole: cicd-deploy-role (mit allen nötigen Rechten für CI/CD)
ClusterRoleBinding: Verbindet ServiceAccount mit ClusterRole
Kubeconfig: Für GitHub Actions Workflows


1. ServiceAccount und RBAC erstellen:

# Auf dem Master Server (mit Admin-Rechten)
# Erstelle die RBAC-Manifeste

cat > /tmp/cicd-rbac.yaml << 'EOF'
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cicd-deploy
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cicd-deploy-role
rules:
  # Namespaces verwalten
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["create", "get", "list", "watch"]
  # Deployments, Services, ConfigMaps, Secrets
  - apiGroups: ["apps"]
    resources: ["deployments", "daemonsets", "statefulsets"]
    verbs: ["create", "update", "patch", "delete", "get", "list", "watch"]
  - apiGroups: [""]
    resources: ["services", "configmaps", "secrets", "pods", "endpoints"]
    verbs: ["create", "update", "patch", "delete", "get", "list", "watch"]
  # ServiceAccounts
  - apiGroups: [""]
    resources: ["serviceaccounts"]
    verbs: ["create", "update", "patch", "get", "list", "watch"]
  # Für Helm (falls verwendet)
  - apiGroups: ["helm.cattle.io"]
    resources: ["helmchartconfigs", "helmcharts"]
    verbs: ["*"]
  # Für Verifikation
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list"]
  # Für Metrics Server
  - apiGroups: ["metrics.k8s.io"]
    resources: ["*"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cicd-deploy-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cicd-deploy-role
subjects:
  - kind: ServiceAccount
    name: cicd-deploy
    namespace: kube-system
EOF

# RBAC anwenden
kubectl apply -f /tmp/cicd-rbac.yaml

# Prüfen
kubectl get serviceaccount cicd-deploy -n kube-system
kubectl get clusterrole cicd-deploy-role
kubectl get clusterrolebinding cicd-deploy-binding


2. ServiceAccount-Token abrufen:

# Warte kurz, bis das Token-Secret erstellt wurde
sleep 5

# Token abrufen
SECRET_NAME=$(kubectl get serviceaccount cicd-deploy -n kube-system -o jsonpath='{.secrets[0].name}')
TOKEN=$(kubectl get secret $SECRET_NAME -n kube-system -o jsonpath='{.data.token}' | base64 -d)

# CA-Zertifikat abrufen
CA_CERT=$(kubectl get secret $SECRET_NAME -n kube-system -o jsonpath='{.data.ca\.crt}')

# Cluster-Endpoint abrufen
CLUSTER_ENDPOINT=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')

echo "Token: $TOKEN"
echo "CA Cert: $CA_CERT"
echo "Cluster Endpoint: $CLUSTER_ENDPOINT"


3. Kubeconfig generieren:

# Kubeconfig für CI/CD erstellen
cat > ~/kubeconfig-cicd.yaml << EOF
apiVersion: v1
kind: Config
clusters:
- name: cluster
  cluster:
    server: $CLUSTER_ENDPOINT
    certificate-authority-data: $CA_CERT
contexts:
- name: cicd-deploy
  context:
    cluster: cluster
    user: cicd-deploy
    namespace: kube-system
current-context: cicd-deploy
users:
- name: cicd-deploy
  user:
    token: $TOKEN
EOF

# Prüfen
kubectl --kubeconfig=~/kubeconfig-cicd.yaml get nodes
kubectl --kubeconfig=~/kubeconfig-cicd.yaml get namespaces


4. Kubeconfig für GitHub Secret vorbereiten:

# Kubeconfig anzeigen (für GitHub Secret kopieren)
cat ~/kubeconfig-cicd.yaml

# Oder base64-kodiert (falls gewünscht)
cat ~/kubeconfig-cicd.yaml | base64 -w 0


5. GitHub Secret setzen:

# Gehe zu GitHub Repository → Settings → Secrets and variables → Actions
# Erstelle/aktualisiere Secret: KUBECONFIG
# Wert: Inhalt von ~/kubeconfig-cicd.yaml (entweder Plain-Text oder base64)


6. Verifikation:

# Test mit der neuen kubeconfig
kubectl --kubeconfig=~/kubeconfig-cicd.yaml get nodes
kubectl --kubeconfig=~/kubeconfig-cicd.yaml create namespace test-namespace
kubectl --kubeconfig=~/kubeconfig-cicd.yaml delete namespace test-namespace

# Prüfe, ob der ServiceAccount die richtigen Rechte hat
kubectl --kubeconfig=~/kubeconfig-cicd.yaml auth can-i create deployments --all-namespaces
kubectl --kubeconfig=~/kubeconfig-cicd.yaml auth can-i create serviceaccounts --all-namespaces
kubectl --kubeconfig=~/kubeconfig-cicd.yaml auth can-i create namespaces


7. Troubleshooting:

# Falls Token nicht verfügbar ist, manuell erstellen:
kubectl apply -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: cicd-deploy-token
  namespace: kube-system
  annotations:
    kubernetes.io/service-account.name: cicd-deploy
type: kubernetes.io/service-account-token
EOF

# Dann erneut Token abrufen (siehe Schritt 2)


# Falls Rechte nicht ausreichen, ClusterRole erweitern:
# Bearbeite /tmp/cicd-rbac.yaml und füge weitere resources/verbs hinzu
# Dann: kubectl apply -f /tmp/cicd-rbac.yaml


# Hinweise:
# - Der ServiceAccount hat Cluster-weite Rechte (nicht nur namespace-spezifisch)
# - Die kubeconfig sollte sicher aufbewahrt werden (nur für CI/CD)
# - Bei Problemen: Prüfe mit 'kubectl auth can-i' ob die Rechte korrekt sind

